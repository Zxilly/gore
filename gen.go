// This file is part of GoRE.
//
// Copyright (C) 2019-2023 GoRE Authors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

//go:build gore_generate
// +build gore_generate

// This program generates stdpkgs_gen.go and goversion_gen.go. It can be invoked by running
// go generate

package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/format"
	"golang.org/x/mod/semver"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"time"
)

var packageTemplate = template.Must(template.New("").Parse(`// This file is part of GoRE.
//
// Copyright (C) 2019-2021 GoRE Authors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

// Code generated by go generate; DO NOT EDIT.
// This file was generated at
// {{ .Timestamp }}

package gore

var stdPkgs = map[string]struct{}{
{{- range .StdPkg }}
	{{ printf "\"%s\": {}" . }},
{{- end }}
}
`))

var goversionTemplate = template.Must(template.New("").Parse(`// This file is part of GoRE.
//
// Copyright (C) 2019-2021 GoRE Authors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

// Code generated by go generate; DO NOT EDIT.
// This file was generated at
// {{ .Timestamp }}

package gore

var goversions = map[string]*GoVersion{
{{- range .GoVersions }}
	{{ printf "\"%s\": {Name: \"%s\", SHA: \"%s\", Timestamp: \"%s\"}" .Name .Name .Sha .Date }},
{{- end }}
}
`))

const moduleDataHeader = `
// This file is part of GoRE.
//
// Copyright (C) 2019-2023 GoRE Authors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

// Code generated by go generate; DO NOT EDIT.

package gore

`

var client = &http.Client{}

var authRequest func(*http.Request)

func init() {
	token := os.Getenv("GITHUB_TOKEN")
	if token != "" {
		authRequest = func(r *http.Request) {
			r.Header.Set("Authorization", "Bearer "+token)
		}
	} else {
		authRequest = func(r *http.Request) {}
	}
}

type ghResp struct {
	Sha       string   `json:"sha"`
	Url       string   `json:"url"`
	Trees     []ghTree `json:"tree"`
	Truncated bool     `json:"truncated"`
}

type ghTree struct {
	Path    string `json:"path"`
	Mode    string `json:"mode"`
	Gittype string `json:"type"`
	Sha     string `json:"sha"`
	Size    int    `json:"size"`
	Url     string `json:"url"`
}

const (
	requestURLFormatStr       = "https://api.github.com/repos/golang/go/git/trees/%s?recursive=0"
	commitRequestURLFormatStr = "https://api.github.com/repos/golang/go/git/commits/%s"
	outputFile                = "stdpkg_gen.go"
	goversionOutputFile       = "goversion_gen.go"
	moduleDataOutputFile      = "moduledata_gen.go"
)

var (
	tagsRequestURL = "https://api.github.com/repos/golang/go/tags"
)

var (
	excludedPaths = []string{"src/cmd"}
)

type tagResp struct {
	Name   string
	Commit *commitShort
}

type commitShort struct {
	Sha string
	URL string
}

type commitLong struct {
	Sha       string
	Committer committer
}

type committer struct {
	Name string
	Date string
}

type goversion struct {
	Name string
	Sha  string
	Date string
}

// diffCode returns false if a and b have different other than the date.
func diffCode(a, b string) bool {
	if a == b {
		return false
	}

	aLines := strings.Split(a, "\n")
	bLines := strings.Split(b, "\n")

	// ignore the license and the date
	aLines = aLines[21:]
	bLines = bLines[21:]

	if len(aLines) != len(bLines) {
		return true
	}

	for i := 0; i < len(aLines); i++ {
		if aLines[i] != bLines[i] {
			return true
		}
	}

	return false
}

func writeOnDemand(new []byte, target string) {
	old, err := os.ReadFile(target)
	if err != nil {
		fmt.Println("Error when reading the old file:", target, err)
		return
	}

	old, _ = format.Source(old)
	new, _ = format.Source(new)

	// Compare the old and the new.
	if !diffCode(string(old), string(new)) {
		fmt.Println(target + " no changes.")
		return
	}

	fmt.Println(target + " changes detected.")

	// Write the new file.
	err = os.WriteFile(target, new, 0664)
	if err != nil {
		fmt.Println("Error when writing the new file:", err)
		return
	}
}

func generateGoVersions() {
	tags := make([]*tagResp, 0)

	// Fetch all tags

	var requestURL *string

	requestURL = &tagsRequestURL
	for *requestURL != "" {
		fmt.Println("Fetching latests tags")
		req, _ := http.NewRequest(http.MethodGet, *requestURL, nil)
		authRequest(req)
		resp, err := client.Do(req)
		if err != nil {
			fmt.Println("Error when fetching tags:", err.Error())
			_ = resp.Body.Close()
			continue
		}
		next := getNextPageURL(resp)
		*requestURL = next
		body, err := io.ReadAll(resp.Body)
		_ = resp.Body.Close()
		if err != nil {
			fmt.Println("Error when ready response body:", err)
			continue
		}
		var newTags []*tagResp
		err = json.Unmarshal(body, &newTags)
		if err != nil {
			fmt.Println("Error when parsing the json:", string(body), err)
			continue
		}
		tags = append(tags, newTags...)
	}

	// Get mode commit info for new tags

	f, err := os.OpenFile(filepath.Join("resources", "goversions.csv"), os.O_CREATE|os.O_RDWR, 0664)
	if err != nil {
		fmt.Println("Error when opening goversions.csv:", err)
		return
	}
	defer func(f *os.File) {
		_ = f.Close()
	}(f)
	knownVersions, err := getStoredGoversions(f)
	if err != nil {
		fmt.Println("Error when getting stored go versions:", err)
		return
	}

	_, err = fmt.Fprintln(f, "version,sha,date")
	if err != nil {
		fmt.Println("Error when writing csv header:", err)
		return
	}

	for _, tag := range tags {
		if strings.HasPrefix(tag.Name, "weekly") || strings.HasPrefix(tag.Name, "release") {
			continue
		}
		if v, known := knownVersions[tag.Name]; known {
			_, _ = fmt.Fprintf(f, "%s,%s,%s\n", v.Name, v.Sha, v.Date)
			continue
		}

		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf(commitRequestURLFormatStr, tag.Commit.Sha), nil)
		authRequest(req)
		resp, err := client.Do(req)
		if err != nil {
			fmt.Println("Error when fetching commit info:", err)
			_ = resp.Body.Close()
			continue
		}
		body, err := io.ReadAll(resp.Body)
		_ = resp.Body.Close()

		var commit commitLong
		err = json.Unmarshal(body, &commit)
		if err != nil {
			fmt.Println("Error when parsing commit json:", err)
			continue
		}
		_, _ = fmt.Fprintf(f, "%s,%s,%s\n", tag.Name, commit.Sha, commit.Committer.Date)
		fmt.Println("New tag found:", tag.Name)
		knownVersions[tag.Name] = &goversion{Name: tag.Name, Sha: commit.Sha, Date: commit.Committer.Date}
	}

	// Generate the code.
	buf := bytes.NewBuffer(nil)

	err = goversionTemplate.Execute(buf, struct {
		Timestamp  time.Time
		GoVersions map[string]*goversion
	}{
		Timestamp:  time.Now().UTC(),
		GoVersions: knownVersions,
	})
	if err != nil {
		fmt.Println("Error when generating the code:", err)
		return
	}

	writeOnDemand(buf.Bytes(), goversionOutputFile)
}

func getStoredGoversions(f *os.File) (map[string]*goversion, error) {
	vers := make(map[string]*goversion)
	r := bufio.NewScanner(f)
	// Read header
	if !r.Scan() {
		return nil, errors.New("empty file")
	}
	r.Text()

	for r.Scan() {
		row := r.Text()
		if row == "" {
			continue
		}
		data := strings.Split(row, ",")
		if data[0] == "" {
			// No version
			continue
		}
		version := strings.TrimSpace(data[0])
		sha := strings.TrimSpace(data[1])
		date := strings.TrimSpace(data[2])
		vers[version] = &goversion{Name: version, Sha: sha, Date: date}
	}
	_, err := f.Seek(0, 0)
	return vers, err
}

func getNextPageURL(r *http.Response) string {
	h := r.Header.Get("Link")
	if h == "" {
		return ""
	}
	// Either we this type:
	// <https://api.github.com/repositories/23096959/tags?page=2>; rel="next", <https://api.github.com/repositories/23096959/tags?page=8>; rel="last"
	// or this type:
	// <https://api.github.com/repositories/23096959/tags?page=7>; rel="prev", <https://api.github.com/repositories/23096959/tags?page=1>; rel="first"
	data := strings.Split(h, ",")
	for _, l := range data {
		ll := strings.Split(l, ";")
		if len(ll) != 2 {
			continue
		}
		if strings.TrimSpace(ll[1]) != "rel=\"next\"" {
			continue
		}
		return strings.TrimLeft(strings.TrimRight(strings.TrimSpace(ll[0]), ">"), "<")
	}
	return ""
}

func skipPath(path string) bool {
	for _, exclude := range excludedPaths {
		if strings.HasPrefix(path, exclude) {
			return true
		}
	}
	return false
}

func typeDef(b *bytes.Buffer, st reflect.Type, bits int) {
	typeName := "uint64"
	if bits == 32 {
		typeName = "uint32"
	}

	_, _ = fmt.Fprintf(b, "type %s%d struct {\n", st.Name(), bits)

	for i := 0; i < st.NumField(); i++ {
		field := st.Field(i)
		fieldName := strings.ToUpper(field.Name[:1]) + field.Name[1:]
		t := field.Type.Kind()
		switch t {
		case reflect.Uintptr:
			_, _ = fmt.Fprintf(b, "%s %s\n", fieldName, typeName)
		case reflect.String:
			_, _ = fmt.Fprintf(b, "%s, %[1]slen %s\n", fieldName, typeName)
		case reflect.Pointer:
			_, _ = fmt.Fprintf(b, "%s %s\n", fieldName, typeName)
		case reflect.Slice:
			_, _ = fmt.Fprintf(b, "%s, %[1]slen, %[1]scap %s\n", fieldName, typeName)

		default:
			panic(fmt.Sprintf("unhandled type: %+v", t))
		}
	}

	_, _ = fmt.Fprint(b, "}\n\n")
}

func toModuledata(b *bytes.Buffer, st reflect.Type, bits int) {
	_, _ = fmt.Fprintf(b, "func (md %s%d) toModuledata() moduledata {\n", st.Name(), bits)
	_, _ = fmt.Fprint(b, "return moduledata{\n")

	for _, names := range [][2]string{
		{"Text", "Text"},
		{"NoPtrData", "Noptrdata"},
		{"Data", "Data"},
		{"Bss", "Bss"},
		{"NoPtrBss", "Noptrbss"},
		{"Types", "Types"},
	} {
		modFieldE(b, st, bits, names[0], names[1])
	}

	for _, names := range [][2]string{
		{"Typelink", "Typelinks"},
		{"ITabLink", "Itablinks"},
		{"FuncTab", "Ftab"},
		{"PCLNTab", "Pclntable"},
	} {
		modFieldLen(b, st, bits, names[0], names[1])
	}

	modFieldVal(b, st, bits, "GoFunc", "Gofunc")

	_, _ = fmt.Fprint(b, "}\n}\n\n")
}

func modFieldE(b *bytes.Buffer, st reflect.Type, bits int, modName, parsedName string) {
	endName := "E" + strings.ToLower(parsedName)
	if _, ok := st.FieldByName(strings.ToLower(parsedName)); !ok {
		return
	}
	if bits == 32 {
		_, _ = fmt.Fprintf(b, "%sAddr: uint64(md.%[3]s),\n%[1]sLen: uint64(md.%s - md.%s),\n", modName, endName, parsedName)
	} else {
		_, _ = fmt.Fprintf(b, "%sAddr: md.%[3]s,\n%[1]sLen: md.%s - md.%s,\n", modName, endName, parsedName)
	}
}

func modFieldLen(b *bytes.Buffer, st reflect.Type, bits int, modName, parsedName string) {
	lenName := parsedName + "len"
	if _, ok := st.FieldByName(strings.ToLower(parsedName)); !ok {
		return
	}
	if bits == 32 {
		_, _ = fmt.Fprintf(b, "%sAddr: uint64(md.%s),\n%[1]sLen: uint64(md.%[3]s),\n", modName, parsedName, lenName)
	} else {
		_, _ = fmt.Fprintf(b, "%sAddr: md.%s,\n%[1]sLen: md.%[3]s,\n", modName, parsedName, lenName)
	}
}

func modFieldVal(b *bytes.Buffer, st reflect.Type, bits int, modName, parsedName string) {
	if _, ok := st.FieldByName(strings.ToLower(parsedName)); !ok {
		return
	}
	if bits == 32 {
		_, _ = fmt.Fprintf(b, "%sVal: uint64(md.%s),\n", modName, parsedName)
	} else {
		_, _ = fmt.Fprintf(b, "%sVal: md.%s,\n", modName, parsedName)
	}
}

func generateModuleData() {
	b := &bytes.Buffer{}
	b.WriteString(moduleDataHeader)

	for _, iface := range []any{
		moduledata20{},
		moduledata18{},
		moduledata16{},
		moduledata8{},
		moduledata7{},
		moduledata5{},
	} {
		o := reflect.TypeOf(iface)
		typeDef(b, o, 64)
		toModuledata(b, o, 64)
		typeDef(b, o, 32)
		toModuledata(b, o, 32)
	}

	out, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(moduleDataOutputFile, out, 0o666)
	if err != nil {
		panic(err)
	}
}

/*
	Internal module structures from Go's runtime.
	TODO: auto extract from golang source runtime package.
*/

// Moduledata structure for Go 1.20 and newer (at least up to the last field covered here)

type moduledata20 struct {
	pcHeader     *pcHeader
	funcnametab  []byte
	cutab        []uint32
	filetab      []byte
	pctab        []byte
	pclntable    []byte
	ftab         []functab
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	covctrs, ecovctrs     uintptr
	end, gcdata, gcbss    uintptr
	types, etypes         uintptr
	rodata                uintptr
	gofunc                uintptr // go.func.*

	textsectmap []textsect
	typelinks   []int32 // offsets from types
	itablinks   []*itab
}

// Moduledata structure for Go 1.18 and Go 1.19

type moduledata18 struct {
	pcHeader     *pcHeader
	funcnametab  []byte
	cutab        []uint32
	filetab      []byte
	pctab        []byte
	pclntable    []byte
	ftab         []functab
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr
	types, etypes         uintptr
	rodata                uintptr
	gofunc                uintptr // go.func.*

	textsectmap []textsect
	typelinks   []int32 // offsets from types
	itablinks   []*itab
}

// Moduledata structure for Go 1.16 to 1.17

type moduledata16 struct {
	pcHeader     *pcHeader
	funcnametab  []byte
	cutab        []uint32
	filetab      []byte
	pctab        []byte
	pclntable    []byte
	ftab         []functab
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr
	types, etypes         uintptr

	textsectmap []textsect
	typelinks   []int32 // offsets from types
	itablinks   []*itab
}

// Moduledata structure for Go 1.8 to 1.15

type moduledata8 struct {
	pclntable    []byte
	ftab         []functab
	filetab      []uint32
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr
	types, etypes         uintptr

	textsectmap []textsect
	typelinks   []int32 // offsets from types
	itablinks   []*itab
}

// Moduledata structure for Go 1.7

type moduledata7 struct {
	pclntable    []byte
	ftab         []functab
	filetab      []uint32
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr
	types, etypes         uintptr

	typelinks []int32 // offsets from types
	itablinks []*itab
}

// Moduledata structure for Go 1.5 to 1.6

type moduledata5 struct {
	pclntable    []byte
	ftab         []functab
	filetab      []uint32
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr

	typelinks []*_type
}

// dummy definitions
type initTask struct{}
type pcHeader struct{}
type functab struct{}
type textsect struct{}
type itab struct{}
type ptabEntry struct{}
type modulehash struct{}
type _type struct{}

func generateStdPkgs() {
	collect := func(ver string) []string {
		resp, err := client.Get(fmt.Sprintf(requestURLFormatStr, "master"))
		if err != nil {
			fmt.Println("Error when fetching go src data:", err)
			return nil
		}
		defer func(Body io.ReadCloser) {
			_ = Body.Close()
		}(resp.Body)
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Error when reading response body:", err)
			return nil
		}
		var master ghResp
		err = json.Unmarshal(body, &master)
		if err != nil {
			fmt.Println("Error when decoding the response body:", err)
			return nil
		}
		var stdPkgs []string
		for _, tree := range master.Trees {
			if tree.Gittype != "tree" {
				continue
			}
			if !strings.HasPrefix(tree.Path, "src") || skipPath(tree.Path) {
				continue
			}
			// Skip src folder.
			if tree.Path == "src" {
				continue
			}
			// Strip "src/" and add to the list.
			stdPkgs = append(stdPkgs, strings.TrimPrefix(tree.Path, "src/"))
		}

		return stdPkgs
	}

	f, err := os.OpenFile(filepath.Join("resources", "goversions.csv"), os.O_CREATE|os.O_RDWR, 0664)
	if err != nil {
		fmt.Println("Error when opening goversions.csv:", err)
		return
	}
	defer func(f *os.File) {
		_ = f.Close()
	}(f)
	knownVersions, err := getStoredGoversions(f)

	branchs := map[string]struct{}{}
	for ver := range knownVersions {
		rawver := "v" + strings.TrimPrefix(ver, "go")
		sver := semver.MajorMinor(rawver)
		if sver != "" {
			sver = "go" + strings.TrimPrefix(sver, "v")
			branchs["release-branch."+sver] = struct{}{}
		}
	}

	stdpkgsSet := map[string]struct{}{}

	for branch := range branchs {
		fmt.Println("Fetching std pkgs for branch:", branch)
		pkgs := collect(branch)
		for _, pkg := range pkgs {
			stdpkgsSet[pkg] = struct{}{}
		}
	}

	stdPkgs := make([]string, 0, len(stdpkgsSet))
	for pkg := range stdpkgsSet {
		stdPkgs = append(stdPkgs, pkg)
	}

	// Generate the code.
	buf := bytes.NewBuffer(nil)

	err = packageTemplate.Execute(buf, struct {
		Timestamp time.Time
		StdPkg    []string
	}{
		Timestamp: time.Now().UTC(),
		StdPkg:    stdPkgs,
	})
	if err != nil {
		fmt.Println("Error when generating the code:", err)
		return
	}

	writeOnDemand(buf.Bytes(), outputFile)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("go run gen.go [stdpkgs|goversion|moduledata]")
		return
	}

	switch os.Args[1] {
	case "stdpkgs":
		generateStdPkgs()
	case "goversion":
		generateGoVersions()
	case "moduledata":
		generateModuleData()
	}
}
